
resource "aws_redshift_cluster" "default" {
  cluster_identifier = var.cluster_identifier
  database_name      = var.db_name
  master_username    = var.master_username
  master_password    = var.master_password
  node_type          = var.node_type
  cluster_type       = "single-node"

  publicly_accessible = true
  skip_final_snapshot = true

  vpc_security_group_ids = [aws_security_group.redshift_sg.id]
  iam_roles              = [var.iam_role_arn]

  tags = {
    Name        = "${var.project_name}-redshift-cluster"
    Environment = var.environment
  }
}

resource "aws_security_group" "redshift_sg" {
  name        = "${var.project_name}-redshift-sg"
  description = "Allow inbound traffic to Redshift"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = 5439
    to_port     = 5439
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${var.project_name}-redshift-sg"
  }
}

# This resource executes the DDL script to create schemas and tables in the Redshift cluster.
# It runs after the cluster is successfully created.
resource "aws_redshiftdata_statement" "create_schema" {
  # Ensure this runs only after the cluster is available.
  depends_on = [aws_redshift_cluster.default]

  cluster_identifier = aws_redshift_cluster.default.cluster_identifier
  database           = aws_redshift_cluster.default.database_name
  db_user            = aws_redshift_cluster.default.master_username

  # Reads the content of the SQL script generated by SCT.
  # The path is relative to the module's location.
  sql = file("${path.module}/../../../scripts/sql/create_redshift_schema.sql")

  # It's good practice to wait for the statement to complete during terraform apply.
  wait_for_completion = true
}
